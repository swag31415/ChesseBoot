/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package ChessBot;

import java.awt.AWTException;
import java.awt.Robot;
import java.awt.Color;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.function.Function;

import xyz.niflheim.stockfish.StockfishClient;
import xyz.niflheim.stockfish.engine.enums.Option;
import xyz.niflheim.stockfish.engine.enums.Query;
import xyz.niflheim.stockfish.engine.enums.QueryType;
import xyz.niflheim.stockfish.engine.enums.Variant;
import xyz.niflheim.stockfish.exceptions.StockfishInitException;

import java.awt.Rectangle;
import java.awt.Toolkit;
import java.awt.event.InputEvent;

public class App {

    public static int startX = -1, endX = -1, startY = -1, endY = -1;

    public static void main(String[] args) throws IOException, AWTException, StockfishInitException {
        Color light = new Color(238, 238, 210);
        Color dark = new Color(118, 150, 86);
        Color light_selected = new Color(246, 246, 130);
        Color dark_selected = new Color(186, 202, 68);
        Robot r = new Robot();

        StockfishClient client = new StockfishClient.Builder()
                .setInstances(4)
                .setOption(Option.Minimum_Thinking_Time, 50) // Minimum thinking time Stockfish will take
                .setOption(Option.Skill_Level, 20) // Stockfish skill level 0-20
                .setVariant(Variant.BMI2).build();

        Double[][] Pieces = getPieces(r, light, dark, light_selected, dark_selected);
        boolean isWhite = getIsWhite(Pieces);
        Map<Double[], String> PieceMap = generatePieceMap(Pieces, isWhite);

        String fen = "";
        int count = 0;
        int threshold = 3;
        while (true) {
            String guess = guessBoard(PieceMap, getPieces(r, light, dark, light_selected, dark_selected), isWhite);
            if (guess.equals(fen)) {
                count++;
            } else {
                fen = guess;
                count = 0;
            }

            if (count >= threshold) {
                System.out.println(fen);
                makeNextMove(client, r, fen, isWhite);
                count = 0;
            }
        }
    }

    public static boolean getIsWhite(Double[][] pieces) {
        return pieces[0][0] < pieces[63][0];
    }

    public static void makeMove(Robot r, String move, boolean isWhite, int patMillis) {
        int x_i = move.charAt(0) - 'a' + 1;
        int y_i = move.charAt(1) - '1' + 1;
        int x = move.charAt(2) - 'a' + 1;
        int y = move.charAt(3) - '1' + 1;

        int xScale = (endX - startX) / 8;
        int yScale = (endY - startY) / 8;

        x_i = startX + ((isWhite ? x_i : 9 - x_i) * xScale) - (xScale / 2);
        y_i = startY + ((!isWhite ? y_i : 9 - y_i) * yScale) - (yScale / 2);
        x = startX + ((isWhite ? x : 9 - x) * xScale) - (xScale / 2);
        y = startY + ((!isWhite ? y : 9 - y) * yScale) - (yScale / 2);

        r.setAutoDelay(patMillis);

        r.mouseMove(x_i, y_i);
        r.mousePress(InputEvent.BUTTON1_DOWN_MASK);
        r.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
        r.mouseMove(x, y);
        r.mousePress(InputEvent.BUTTON1_DOWN_MASK);
        r.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
        r.mouseMove(startX - 10, endY + 10);
    }

    public static void makeNextMove(StockfishClient client, Robot r, String fen, boolean isWhite) {
        Query query = new Query.Builder(QueryType.Best_Move).setFen(fen).build();

        client.submit(query, result -> {
            makeMove(r, result, isWhite, 50);
            System.out.println(result);
        });
    }

    public static Double[][] getPieces(Robot r, Color light, Color dark, Color light_selected, Color dark_selected) {
        Rectangle capture = new Rectangle(Toolkit.getDefaultToolkit().getScreenSize());
        Color[][] Image = Utils.getColors(r.createScreenCapture(capture));

        Image = Utils.filterColors(Image, light, light_selected);
        Image = Utils.filterColors(Image, dark, dark_selected);

        Color[][] Board = getBoard(Image, light, dark);

        return getPieces(Board, light, dark);
    }

    public static String guessBoard(Map<Double[], String> pieceMap, Double[][] pieces, boolean isWhite) {
        StringBuilder board = new StringBuilder();
        for (int i = 0; i < 8; i++) {
            int empties = 0;
            for (int j = 0; j < 8; j++) {
                String guess = guessPiece(pieceMap, pieces[(8 * i) + j]);
                if (guess.equals(" ")) {
                    empties++;
                } else {
                    board.append((empties != 0) ? empties : "");
                    empties = 0;
                    board.append(guess);
                }
            }
            board.append((empties != 0) ? empties : "");
            board.append((i == 7) ? "" : "/");
        }
        if (!isWhite) {
            board.reverse();
        }
        board.append(isWhite ? " w" : " b");
        board.append(" - - 0 1");

        return board.toString();
    }

    public static String guessPiece(Map<Double[], String> pieceMap, Double[] piece) {
        String guess = "";
        double error = Double.MAX_VALUE;
        for (Entry<Double[], String> entry : pieceMap.entrySet()) {
            double err = 0;
            for (int i = 0; i < entry.getKey().length; i++) {
                err += Math.pow(entry.getKey()[i] - piece[i], 2);
            }
            if (err < error) {
                error = err;
                guess = entry.getValue();
            }
        }
        return guess;
    }

    public static Map<Double[], String> generatePieceMap(Double[][] pieces, boolean isWhite) {
        Map<Double[], String> pieceMap = new HashMap<Double[], String>();
        Double[] emptyTile = {0.0, 0.0, 0.0, 0.0};
        int offset = 48;
        String[] topSet = new String[16];
        String[] bottomSet = new String[16];

        if (isWhite) {
            String[] blackSet = {"r", "n", "b", "q", "k", "b", "n", "r", "p", "p", "p", "p", "p", "p", "p", "p"};
            String[] whiteSet = {"P", "P", "P", "P", "P", "P", "P", "P", "R", "N", "B", "Q", "K", "B", "N", "R"};
            topSet = blackSet;
            bottomSet = whiteSet;
        } else {
            String[] whiteSet = {"R", "N", "B", "K", "Q", "B", "N", "R", "P", "P", "P", "P", "P", "P", "P", "P"};
            String[] blackSet = {"p", "p", "p", "p", "p", "p", "p", "p", "r", "n", "b", "k", "q", "b", "n", "r"};
            topSet = whiteSet;
            bottomSet = blackSet;
        }
        
        for (int i = 0; i < topSet.length; i++) {
            if (!Arrays.equals(pieces[i], emptyTile)) {
                pieceMap.put(pieces[i], topSet[i]);
            }
        }

        for (int i = 0; i < bottomSet.length; i++) {
            if (!Arrays.equals(pieces[i + offset], emptyTile)) {
                pieceMap.put(pieces[i + offset], bottomSet[i]);
            }
        }

        pieceMap.put(emptyTile, " ");
        return pieceMap;
    }

    public static Double[][] getPieces(Color[][] board, Color light, Color dark) {
        Color[][] pboard = Utils.filterColors(board, Color.BLACK, light, dark);
        int w = (pboard[0].length / 8);
        int h = (pboard.length / 8);
        Double[][] pieces = new Double[64][4];
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                Color[][] tile = Utils.arraySubset(pboard, i * h, ((i + 1) * h) - 1, j * w, ((j + 1) * w) - 1);
                int tw = tile[0].length - 1;
                int th = tile.length - 1;
                pieces[(8 * i) + j][0] = Utils.imgavg(Utils.arraySubset(tile, 0, th/2, 0, tw/2));
                pieces[(8 * i) + j][1] = Utils.imgavg(Utils.arraySubset(tile, 0, th/2, tw/2, tw));
                pieces[(8 * i) + j][2] = Utils.imgavg(Utils.arraySubset(tile, th/2, th, 0, tw/2));
                pieces[(8 * i) + j][3] = Utils.imgavg(Utils.arraySubset(tile, th/2, th, tw/2, tw));
            }
        }
        return pieces;
    }

    public static Color[][] getBoard(Color[][] img, Color light, Color dark) {
        if ((startX == -1) && (startY == -1) && (endX == -1) && (endY == -1)) {
            int h = img.length;
            int w = img[0].length;
            Color[][] img_t = Utils.transpose(img);
            int count = 0;

            Function<Color, Boolean> isLight = c -> {
                return c.getRGB() == light.getRGB();
            };
            Function<Color, Boolean> isDark = c -> {
                return c.getRGB() == dark.getRGB();
            };

            count = 0;
            for (Color[] row : img) {
                Color[] row_f = Utils.flipArray(row);
                int firstLight = Utils.getFirstIndex(row, isLight);
                int lastLight = (w - 1) - Utils.getFirstIndex(row_f, isLight);
                int firstDark = Utils.getFirstIndex(row, isDark);
                int lastDark = (w - 1) - Utils.getFirstIndex(row_f, isDark);

                if ((firstLight != firstDark) || (lastLight != lastDark)) {
                    int first = Math.min(firstLight, firstDark);
                    int last = Math.max(lastLight, lastDark);
                    if ((first == startX) && (last == endX)) {
                        count++;
                    } else {
                        count = 0;
                        startX = first;
                        endX = last;
                    }
                } else {
                    count = 0;
                }

                if (count >= 10) {
                    break;
                }
            }

            count = 0;
            for (Color[] column : img_t) {
                Color[] column_f = Utils.flipArray(column);
                int firstLight = Utils.getFirstIndex(column, isLight);
                int lastLight = (h - 1) - Utils.getFirstIndex(column_f, isLight);
                int firstDark = Utils.getFirstIndex(column, isDark);
                int lastDark = (h - 1) - Utils.getFirstIndex(column_f, isDark);

                if ((firstLight != firstDark) || (lastLight != lastDark)) {
                    int first = Math.min(firstLight, firstDark);
                    int last = Math.max(lastLight, lastDark);
                    if ((first == startY) && (last == endY)) {
                        count++;
                    } else {
                        count = 0;
                        startY = first;
                        endY = last;
                    }
                } else {
                    count = 0;
                }

                if (count >= 10) {
                    break;
                }
            }
        }

        return Utils.arraySubset(img, startY, endY, startX, endX);
    }
}
